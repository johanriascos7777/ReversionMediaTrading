hola google te mostrare mi back y   front  para  que  entres  en  c ontexto,,  dame un alista  de   cada archivo  que te di solo con  algunas  palabras  no mas  de una linea  para  saber  que  tienes  conexto:  backend:  /**
 * types.ts
 * Tipos compartidos del backend.
 */

export type Candle = {
  time:  number   // timestamp ms del CIERRE de la vela
  open:  number
  high:  number
  low:   number
  close: number
  closed: boolean // true = vela cerrada, false = vela en construcciÃ³n
}

export type Timeframe = 'M5' | 'M15'

export type MarketState = 'GREEN' | 'YELLOW' | 'RED'

// Lo que el backend calcula y envÃ­a al frontend
export type MarketSnapshot = {
  timeframe:   Timeframe
  price:       number
  ema100:      number
  atr:         number
  elasticity:  number
  state:       MarketState
  timestamp:   number
}

// Mensaje que el backend emite al frontend via WebSocket propio
export type BackendMessage =
  | { type: 'snapshot'; m5: MarketSnapshot; m15: MarketSnapshot; finalState: MarketState }
  | { type: 'status';   status: 'connecting' | 'connected' | 'disconnected'; message: string }
  | { type: 'error';    message: string }

// Mensaje que llega de Twelve Data WebSocket
export type TwelveTickMessage = {
  event?:     string   // 'price' | 'subscribe-status' | 'heartbeat'
  symbol?:    string
  price?:     number
  timestamp?: number
  exchange?:  string
} /**
 * twelveDataClient.ts
 *
 * Cliente WebSocket hacia Twelve Data.
 * Recibe precio tick a tick y notifica al servidor.
 *
 * Manejo de reconexiÃ³n automÃ¡tica:
 *   Si la conexiÃ³n se cae (internet, reinicio de Twelve Data),
 *   reintenta cada 5 segundos hasta reconectar.
 *   Esto garantiza que el backend nunca quede sin datos silenciosamente.
 */

import WebSocket from 'ws'
import type { TwelveTickMessage } from './types'
import { EventEmitter } from 'events'

const RECONNECT_DELAY_MS = 5_000

export class TwelveDataClient extends EventEmitter {
  private apiKey:  string
  private symbol:  string
  private ws:      WebSocket | null = null
  private stopped: boolean = false

  constructor(apiKey: string, symbol: string) {
    super()
    this.apiKey = apiKey
    this.symbol = symbol
  }

  connect(): void {
    this.stopped = false
    this._connect()
  }

  disconnect(): void {
    this.stopped = true
    this.ws?.close()
  }

  private _connect(): void {
    const url = `wss://ws.twelvedata.com/v1/quotes/price?apikey=${this.apiKey}`

    console.log('[TwelveData] Conectando WebSocket...')
    this.emit('status', 'connecting', 'Conectando con Twelve Data...')

    this.ws = new WebSocket(url)

    this.ws.on('open', () => {
      console.log('[TwelveData] Conectado âœ“')
      this.emit('status', 'connected', 'WebSocket conectado')

      // Suscribirse al sÃ­mbolo
      this.ws!.send(JSON.stringify({
        action: 'subscribe',
        params: { symbols: this.symbol },
      }))
    })

    this.ws.on('message', (raw: Buffer) => {
      let msg: TwelveTickMessage

      try {
        msg = JSON.parse(raw.toString())
      } catch {
        return
      }

      // Solo procesar mensajes de precio
      if (msg.event !== 'price' || !msg.price) return

      this.emit('tick', msg.price, Date.now())
    })

    this.ws.on('error', (err) => {
      console.error('[TwelveData] Error:', err.message)
      this.emit('status', 'disconnected', `Error: ${err.message}`)
    })

    this.ws.on('close', () => {
      console.log('[TwelveData] ConexiÃ³n cerrada')
      this.emit('status', 'disconnected', 'ConexiÃ³n cerrada')

      if (!this.stopped) {
        console.log(`[TwelveData] Reconectando en ${RECONNECT_DELAY_MS / 1000}s...`)
        setTimeout(() => this._connect(), RECONNECT_DELAY_MS)
      }
    })
  }
}/**
 * server.ts â€” Backend completo del Elasticity System
 *
 * Expone dos interfaces:
 *
 *   WebSocket ws://localhost:8080
 *     â†’ snapshots en tiempo real al frontend
 *
 *   HTTP GET http://localhost:8080/history?timeframe=5min
 *     â†’ devuelve las velas histÃ³ricas al frontend (para backtest)
 *     â†’ 0 crÃ©ditos: el backend ya las tiene en memoria
 *
 * Al arrancar:
 *   1. Pide historial M5 + M15 a Twelve Data REST (1 vez al dÃ­a)
 *   2. Pre-calienta CandleBuilders â†’ EMA y percentiles listos
 *   3. Conecta WebSocket de Twelve Data â†’ ticks en tiempo real
 * 
 * VIGILAR  A  const twelveClient = new TwelveDataClient(API_KEY, SYMBOL)
 * twelveClient.connect() para que:
 * -No se duplique
 * -No se reconecte mal
 *-No cree mÃºltiples instancias
 */

import http from 'http'
import WebSocket, { WebSocketServer } from 'ws'
import https from 'https'
import { TwelveDataClient } from './twelveDataClient'
import { CandleBuilder } from './candleBuilder'
import { calculateSnapshot, resolveMultiTF } from './marketEngine'
import type { BackendMessage, Candle, MarketSnapshot } from './types'

// â”€â”€â”€ âš™ï¸ CONFIGURACIÃ“N â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const API_KEY        = 'b584cd192ee6441a86f06373b685283b'
const SYMBOL         = 'EUR/USD'
const PORT           = 8080
const HISTORY_OUTPUT = 500

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const builderM5  = new CandleBuilder('M5')
const builderM15 = new CandleBuilder('M15')

let lastSnapshotM5:  MarketSnapshot | null = null
let lastSnapshotM15: MarketSnapshot | null = null

// Guardamos el historial en memoria para servirlo al frontend
let historicalM5:  Candle[] = []
let historicalM15: Candle[] = []

// â”€â”€â”€ HTTP server (historial + CORS) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const httpServer = http.createServer((req, res) => {
  // CORS â€” permite que el frontend en localhost:5173 acceda
  res.setHeader('Access-Control-Allow-Origin', '*')
  res.setHeader('Access-Control-Allow-Methods', 'GET')
  res.setHeader('Content-Type', 'application/json')

  if (req.url?.startsWith('/history')) {
    const url        = new URL(req.url, `http://localhost:${PORT}`)
    const timeframe  = url.searchParams.get('timeframe') ?? '5min'
    const candles    = timeframe === '15min' ? historicalM15 : historicalM5

    res.writeHead(200)
    res.end(JSON.stringify(candles))
    return
  }

  // Health check
  if (req.url === '/health') {
    res.writeHead(200)
    res.end(JSON.stringify({ status: 'ok', candlesM5: historicalM5.length, candlesM15: historicalM15.length }))
    return
  }

  res.writeHead(404)
  res.end(JSON.stringify({ error: 'Not found' }))
})

// â”€â”€â”€ WebSocket server sobre el mismo puerto HTTP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const wss = new WebSocketServer({ server: httpServer })

function broadcast(msg: BackendMessage): void {
  const data = JSON.stringify(msg)
  wss.clients.forEach((client) => {
    if (client.readyState === WebSocket.OPEN) {
      client.send(data)
    }
  })
}

wss.on('connection', (ws) => {
  console.log('[Server] Frontend conectado')

  if (lastSnapshotM5 && lastSnapshotM15) {
    const finalState = resolveMultiTF(lastSnapshotM5, lastSnapshotM15)
    ws.send(JSON.stringify({
      type: 'snapshot',
      m5:   lastSnapshotM5,
      m15:  lastSnapshotM15,
      finalState,
    } satisfies BackendMessage))
  }

  ws.on('close', () => console.log('[Server] Frontend desconectado'))
})

// â”€â”€â”€ Fetch historial via REST â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

type TwelveCandle = {
  datetime: string
  open:     string
  high:     string
  low:      string
  close:    string
}

function fetchHistoricalCandles(
  interval: '5min' | '15min',
  outputSize: number
): Promise<Candle[]> {
  return new Promise((resolve) => {
    const path =
      `/v1/time_series?symbol=${encodeURIComponent(SYMBOL)}` +
      `&interval=${interval}&outputsize=${outputSize}&apikey=${API_KEY}`

    const req = https.request({ hostname: 'api.twelvedata.com', path, method: 'GET' }, (res) => {
      let raw = ''
      res.on('data', (chunk: Buffer) => { raw += chunk.toString() })
      res.on('end', () => {
        try {
          const data = JSON.parse(raw)
          if (data.status !== 'ok' || !data.values) {
            console.error(`[History] Error ${interval}:`, data.message)
            resolve([])
            return
          }
          const candles: Candle[] = [...(data.values as TwelveCandle[])].reverse().map((c) => ({
            time:   new Date(c.datetime).getTime(),
            open:   parseFloat(c.open),
            high:   parseFloat(c.high),
            low:    parseFloat(c.low),
            close:  parseFloat(c.close),
            closed: true,
          }))
          resolve(candles)
        } catch {
          resolve([])
        }
      })
    })
    req.on('error', () => resolve([]))
    req.end()
  })
}

function warmUpBuilder(builder: CandleBuilder, candles: Candle[]): void {
  candles.forEach((c) => builder.injectHistoricalCandle(c))
  console.log(`[WarmUp] ${builder.getTimeframe()} precalentado con ${candles.length} velas`)
}

// â”€â”€â”€ Procesamiento de ticks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function processTick(price: number, timestamp: number): void {
  builderM5.tick(price, timestamp)
  builderM15.tick(price, timestamp)

  const snapshotM5  = calculateSnapshot(builderM5.getCandles(),  price, 'M5',  timestamp)
  const snapshotM15 = calculateSnapshot(builderM15.getCandles(), price, 'M15', timestamp)

  if (!snapshotM5 || !snapshotM15) return

  lastSnapshotM5  = snapshotM5
  lastSnapshotM15 = snapshotM15

  const finalState = resolveMultiTF(snapshotM5, snapshotM15)
  broadcast({ type: 'snapshot', m5: snapshotM5, m15: snapshotM15, finalState })

  if (Math.random() < 0.05) {
    console.log(
      `[Engine] ${new Date(timestamp).toLocaleTimeString()}`,
      `Â· ${price.toFixed(5)}`,
      `Â· M5: ${snapshotM5.elasticity.toFixed(3)} ${snapshotM5.state}`,
      `Â· M15: ${snapshotM15.elasticity.toFixed(3)} ${snapshotM15.state}`,
      `Â· ${finalState}`
    )
  }
}

// â”€â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function main() {
  console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—')
  console.log('â•‘   Elasticity System â€” Backend      â•‘')
  console.log('â•‘   EUR/USD  Â·  M5 + M15             â•‘')
  console.log(`â•‘   Puerto: ${PORT}                      â•‘`)
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')

  // 1. Cargar historial para pre-calentar
  console.log('[Server] Cargando historial M5 (500 velas)...')
  historicalM5 = await fetchHistoricalCandles('5min', HISTORY_OUTPUT)

  await new Promise((r) => setTimeout(r, 2000))   // pausa entre llamadas REST

  console.log('[Server] Cargando historial M15 (500 velas)...')
  historicalM15 = await fetchHistoricalCandles('15min', HISTORY_OUTPUT)

  if (historicalM5.length  > 0) warmUpBuilder(builderM5,  historicalM5)
  if (historicalM15.length > 0) warmUpBuilder(builderM15, historicalM15)

  // Calcular snapshot inicial con Ãºltimo precio del historial
  if (historicalM5.length > 0 && historicalM15.length > 0) {
    const lastPrice = historicalM5[historicalM5.length - 1].close
    const ts        = historicalM5[historicalM5.length - 1].time
    const snap5     = calculateSnapshot(builderM5.getCandles(),  lastPrice, 'M5',  ts)
    const snap15    = calculateSnapshot(builderM15.getCandles(), lastPrice, 'M15', ts)

    if (snap5 && snap15) {
      lastSnapshotM5  = snap5
      lastSnapshotM15 = snap15
      console.log(
        '[Server] Snapshot inicial:',
        `M5: ${snap5.elasticity.toFixed(3)} ${snap5.state}`,
        `Â· M15: ${snap15.elasticity.toFixed(3)} ${snap15.state}`
      )
    }
  }

  // 2. Arrancar HTTP + WebSocket server
  httpServer.listen(PORT, () => {
    console.log(`[Server] HTTP  â†’ http://localhost:${PORT}/history`)
    console.log(`[Server] WS    â†’ ws://localhost:${PORT}`)
  })

  // 3. Conectar Twelve Data WebSocket
  const twelveClient = new TwelveDataClient(API_KEY, SYMBOL)

  twelveClient.on('tick', processTick)
  twelveClient.on('status', (status: string, message: string) => {
    broadcast({ type: 'status', status: status as 'connecting' | 'connected' | 'disconnected', message })
  })

  twelveClient.connect()

  builderM5.on('candle:closed',  () => console.log(`[Server] Vela M5  cerrada â€” ${builderM5.getClosedCandles().length} velas`))
  builderM15.on('candle:closed', () => console.log(`[Server] Vela M15 cerrada â€” ${builderM15.getClosedCandles().length} velas`))
}

main().catch(console.error) /**
 * marketEngine.ts
 *
 * Motor matemÃ¡tico del backend.
 * Dado un array de velas, calcula EMA100, ATR14, elasticidad y estado.
 *
 * IdÃ©ntico en lÃ³gica al frontend pero en Node.js puro (sin React).
 * Al estar en el backend, los cÃ¡lculos corren una sola vez
 * y el resultado se envÃ­a a todos los clientes conectados.
 */

import type { Candle, MarketState, MarketSnapshot, Timeframe } from './types'

// â”€â”€â”€ configuraciÃ³n (debe coincidir con el frontend) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const EMA_PERIOD = 100
const ATR_PERIOD = 14

// Umbrales del stateEngine â€” se actualizan con calibraciÃ³n
let config = {
  percentileGreen:  80,
  percentileYellow: 60,
  elasticityMin:    1.0,
  elasticityMax:    5.5,
}

export function updateEngineConfig(c: Partial<typeof config>): void {
  config = { ...config, ...c }
}

// â”€â”€â”€ EMA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function calculateEMA(closes: number[], period: number): number {
  if (closes.length === 0) return 0
  if (closes.length < period) return closes[closes.length - 1]

  const alpha = 2 / (period + 1)
  let ema = closes.slice(0, period).reduce((s, v) => s + v, 0) / period

  for (let i = period; i < closes.length; i++) {
    ema = alpha * closes[i] + (1 - alpha) * ema
  }

  return ema
}

// â”€â”€â”€ ATR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function calculateATR(candles: Candle[], period: number): number {
  if (candles.length < 2) return 0.0006

  const trues: number[] = []
  for (let i = 1; i < candles.length; i++) {
    const { high, low } = candles[i]
    const prev = candles[i - 1].close
    trues.push(Math.max(high - low, Math.abs(high - prev), Math.abs(low - prev)))
  }

  const slice = trues.slice(-period)
  return slice.reduce((s, v) => s + v, 0) / slice.length
}

// â”€â”€â”€ Percentile engine (ventana deslizante) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class PercentileEngine {
  private window: number[] = []
  private maxSize: number

  constructor(maxSize = 200) {
    this.maxSize = maxSize
  }

  push(value: number): number {
    this.window.push(value)
    if (this.window.length > this.maxSize) this.window.shift()

    const sorted = [...this.window].sort((a, b) => a - b)
    const rank   = sorted.filter(v => v <= value).length
    return (rank / this.window.length) * 100
  }
}

const percentileM5  = new PercentileEngine(200)
const percentileM15 = new PercentileEngine(200)

// â”€â”€â”€ State resolution â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function resolveState(elasticity: number, percentile: number): MarketState {
  if (
    percentile  >= config.percentileGreen &&
    elasticity  >= config.elasticityMin   &&
    elasticity  <= config.elasticityMax
  ) return 'GREEN'

  if (percentile >= config.percentileYellow) return 'YELLOW'

  return 'RED'
}

// â”€â”€â”€ Snapshot calculator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Dado el array de velas de un timeframe, calcula el snapshot completo.
 * price = precio del Ãºltimo tick (puede ser intracandle)
 */
export function calculateSnapshot(
  candles:   Candle[],
  price:     number,
  timeframe: Timeframe,
  timestamp: number
): MarketSnapshot | null {
  if (candles.length < EMA_PERIOD + 2) return null

  const closes  = candles.map(c => c.close)
  const ema100  = calculateEMA(closes, EMA_PERIOD)
  const atr     = calculateATR(candles, ATR_PERIOD)

  if (atr === 0) return null

  const elasticity = Math.abs(price - ema100) / atr

  const percentileEngine = timeframe === 'M5' ? percentileM5 : percentileM15
  const percentile       = percentileEngine.push(elasticity)

  const state = resolveState(elasticity, percentile)

  return {
    timeframe,
    price,
    ema100,
    atr,
    elasticity,
    state,
    timestamp,
  }
}

// â”€â”€â”€ Multi-timeframe resolver â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export function resolveMultiTF(
  m5:  MarketSnapshot,
  m15: MarketSnapshot
): MarketState {
  if (m5.state === 'GREEN'  && m15.state === 'GREEN')  return 'GREEN'
  if (m5.state === 'GREEN'  && m15.state === 'YELLOW') return 'YELLOW'
  return 'RED'
} /**
 * candleBuilder.ts
 *
 * Construye velas M5/M15 desde ticks en tiempo real.
 * TambiÃ©n acepta velas histÃ³ricas para pre-calentar el engine.
 */

import type { Candle, Timeframe } from './types'
import { EventEmitter } from 'events'

const TIMEFRAME_MS: Record<Timeframe, number> = {
  M5:  5  * 60 * 1000,
  M15: 15 * 60 * 1000,
}

const MAX_CANDLES = 150

export class CandleBuilder extends EventEmitter {
  private timeframe: Timeframe
  private periodMs:  number
  private current:   Candle | null = null
  private closed:    Candle[] = []

  constructor(timeframe: Timeframe) {
    super()
    this.timeframe = timeframe
    this.periodMs  = TIMEFRAME_MS[timeframe]
  }

  /**
   * Inyecta una vela histÃ³rica cerrada directamente al historial.
   * Usado para pre-calentar el engine sin esperar ticks reales.
   */
  injectHistoricalCandle(candle: Candle): void {
    this.closed.push({ ...candle, closed: true })
    if (this.closed.length > MAX_CANDLES) {
      this.closed.shift()
    }
  }

  /**
   * Procesa un tick en tiempo real.
   * Emite 'candle:closed' cuando cierra una vela.
   */
  tick(price: number, timestamp: number): void {
    const periodId = Math.floor(timestamp / this.periodMs)

    if (this.current === null) {
      this.current = this.openCandle(price, periodId)
      this.emit('candle:update', this.current)
      return
    }

    const currentPeriodId = Math.floor(this.current.time / this.periodMs)

    if (periodId !== currentPeriodId) {
      // Cerrar vela actual
      const closedCandle: Candle = { ...this.current, closed: true }
      this.closed.push(closedCandle)
      if (this.closed.length > MAX_CANDLES) this.closed.shift()

      console.log(
        `[CandleBuilder ${this.timeframe}] Vela cerrada:`,
        `O:${closedCandle.open.toFixed(5)}`,
        `H:${closedCandle.high.toFixed(5)}`,
        `L:${closedCandle.low.toFixed(5)}`,
        `C:${closedCandle.close.toFixed(5)}`
      )

      this.emit('candle:closed', closedCandle, this.closed)

      // Abrir nueva vela
      this.current = this.openCandle(price, periodId)
    } else {
      this.current.high  = Math.max(this.current.high, price)
      this.current.low   = Math.min(this.current.low,  price)
      this.current.close = price
    }

    this.emit('candle:update', this.current)
  }

  private openCandle(price: number, periodId: number): Candle {
    return {
      time:   periodId * this.periodMs,
      open:   price,
      high:   price,
      low:    price,
      close:  price,
      closed: false,
    }
  }

  getCandles(): Candle[] {
    if (this.current) return [...this.closed, this.current]
    return [...this.closed]
  }

  getClosedCandles(): Candle[] {
    return [...this.closed]
  }

  getCurrentCandle(): Candle | null {
    return this.current
  }

  getTimeframe(): Timeframe {
    return this.timeframe
  }
}  frontend  import './App.css'

import { useMarketData } from './hooks/useMarketData'
import { useHistoricalData } from './hooks/useHistoricalData'
import { useBacktest } from './hooks/useBacktest'

import { Semaforo } from './components/Semaforo'
import { BacktestMetrics } from './components/BacktestMetrics'
import { ElasticityCard } from './components/ElasticityCard'

import { compareSignalWithHistory } from './backtest/compareSignal'
import { fuseMarketState } from './logic/fuseMarketState'

function App() {
  // ğŸŸ¢ 1. Mercado en tiempo real â€” via backend WebSocket local
  const { data: market, status: wsStatus } = useMarketData()

  // ğŸ“œ 2. Historial real â€” 500 velas M5 via REST (1 llamada al dÃ­a)
  const historical = useHistoricalData()

  // ğŸ§ª 3. Backtest real â€” devuelve BacktestResult | null directamente
  const backtest = useBacktest(historical)

  // â”€â”€ Pantalla de carga / conexiÃ³n â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (!market) {
    return (
      <div style={{
        display: 'flex', alignItems: 'center', justifyContent: 'center',
        height: '100vh', flexDirection: 'column', gap: 12,
        color: '#555', fontFamily: 'monospace',
      }}>
        <div style={{
          width: 10, height: 10, borderRadius: '50%',
          background: wsStatus === 'connecting' ? '#eab308' : '#dc2626',
          boxShadow: wsStatus === 'connecting'
            ? '0 0 10px #eab308'
            : '0 0 10px #dc2626',
        }}/>
        <p style={{ margin: 0, fontSize: 13 }}>
          {wsStatus === 'connecting'
            ? 'Conectando con el backend...'
            : 'Backend desconectado â€” verifica que corre en puerto 8080'}
        </p>
        <p style={{ margin: 0, fontSize: 11, color: '#333' }}>
          ws://localhost:8080
        </p>
      </div>
    )
  }

  // ğŸ§  4. ComparaciÃ³n seÃ±al actual vs histÃ³rico real
  const comparison =
    backtest
      ? compareSignalWithHistory(
          { state: market.finalState, elasticity: market.m5.elasticity },
          backtest
        )
      : null

  // ğŸ§  5. FusiÃ³n final â†’ { state, explanation }
  const fused = fuseMarketState(market.finalState, comparison)

  return (
    <div style={{ padding: 24, maxWidth: 720, margin: '0 auto' }}>
      <h2>EUR/USD â€” Elasticity System</h2>

      {/* Badge de conexiÃ³n con el backend */}
      <div style={{
        display: 'inline-flex', alignItems: 'center', gap: 6,
        padding: '4px 10px', borderRadius: 12, marginBottom: 8,
        background: 'rgba(22,163,74,0.1)', border: '1px solid #16a34a33',
      }}>
        <div style={{
          width: 6, height: 6, borderRadius: '50%',
          background: '#16a34a', boxShadow: '0 0 6px #16a34a',
        }}/>
        <span style={{ fontSize: 11, color: '#16a34a', fontFamily: 'monospace' }}>
          Backend conectado Â· ws://localhost:8080
        </span>
      </div>

      {/* ============================= */}
      {/* ğŸ”µ SECCIÃ“N 1 â€” TIEMPO REAL   */}
      {/* ============================= */}
      <div style={{
        marginTop: 16, padding: 16,
        border: '1px solid #2a2a2a', borderRadius: 8,
      }}>
        <h3>ğŸŸ¢ Tiempo real (motor)</h3>
        <p style={{ opacity: 0.7, fontSize: 14 }}>
          Precio tick a tick via WebSocket. EMA y ATR calculados
          sobre velas cerradas reales construidas en el backend.
        </p>
        <p>M5 Elasticidad: {market.m5.elasticity.toFixed(2)} | {market.m5.state}</p>
        <p>M15 Elasticidad: {market.m15.elasticity.toFixed(2)} | {market.m15.state}</p>
        <Semaforo state={market.finalState} label="Actual" />
      </div>

      {/* ============================= */}
      {/* ğŸ“Š SECCIÃ“N 2 â€” ELASTICIDAD   */}
      {/* ============================= */}
      <div style={{
        marginTop: 32, padding: 16,
        border: '1px solid #2a2a2a', borderRadius: 8,
      }}>
        <h3>ğŸ“Š Elasticidad (detalle visual)</h3>
        <p style={{ opacity: 0.7, fontSize: 14 }}>
          Muestra cuÃ¡nto se ha estirado el precio respecto a su promedio
          (EMA100). Responde al "Â¿por quÃ©?" del semÃ¡foro.
        </p>
        <ElasticityCard
          m5={market.m5}
          m15={market.m15}
          fusedState={market.finalState}
        />
      </div>

      {/* ============================= */}
      {/* ğŸŸ  SECCIÃ“N 3 â€” BACKTEST      */}
      {/* ============================= */}
      <div style={{
        marginTop: 32, padding: 16,
        border: '1px solid #2a2a2a', borderRadius: 8,
      }}>
        <h3>ğŸ§ª Backtesting (histÃ³rico)</h3>
        <p style={{ opacity: 0.7, fontSize: 14 }}>
          Resultados estadÃ­sticos sobre las Ãºltimas 500 velas M5.
          Los umbrales se calibran automÃ¡ticamente con estos datos.
        </p>
        {backtest
          ? <BacktestMetrics data={backtest} />
          : <p style={{ opacity: 0.5, fontSize: 13 }}>
              Cargando velas histÃ³ricas...
            </p>
        }
      </div>

      {/* ============================= */}
      {/* ğŸŸ£ SECCIÃ“N 4 â€” COMPARACIÃ“N   */}
      {/* ============================= */}
      <div style={{
        marginTop: 32, padding: 16,
        border: '1px solid #2a2a2a', borderRadius: 8,
      }}>
        <h3>ğŸ“Š ComparaciÃ³n seÃ±al actual vs histÃ³rico</h3>
        <p style={{ opacity: 0.7, fontSize: 14 }}>
          Busca situaciones histÃ³ricas con mismo estado y
          elasticidad similar (Â±0.1) para estimar probabilidad contextual.
        </p>
        {comparison ? (
          <>
            <p>SeÃ±ales similares: {comparison.similarSignals}</p>
            <p>Win rate: {comparison.winRate.toFixed(2)}%</p>
            <p>Promedio barras a revertir: {comparison.avgBarsToRevert.toFixed(2)}</p>
          </>
        ) : (
          <p style={{ opacity: 0.6 }}>Cargando contexto histÃ³rico...</p>
        )}
      </div>

      {/* ============================= */}
      {/* ğŸ”´ SECCIÃ“N 5 â€” SEÃ‘AL FINAL   */}
      {/* ============================= */}
      <div style={{
        marginTop: 32, padding: 16,
        border: '2px solid #444', borderRadius: 8,
        background: 'rgba(255,255,255,0.02)',
      }}>
        <h3>ğŸš¦ SeÃ±al confirmada</h3>
        <p style={{ opacity: 0.7, fontSize: 14 }}>
          Resultado final que combina la seÃ±al en tiempo real
          con el contexto histÃ³rico real.
        </p>
        <p style={{
          fontSize: 13, color: '#666',
          background: '#111', border: '1px solid #222',
          borderRadius: 6, padding: '10px 14px',
          margin: '0 0 8px', lineHeight: 1.6,
        }}>
          {fused.explanation}
        </p>
        <Semaforo state={fused.state} label="Confirmado" />
      </div>
    </div>
  )
}

export default App /**
 * useMarketData.ts
 *
 * Conecta al backend local via WebSocket.
 * El backend hace todo el trabajo pesado â€” este hook
 * solo recibe el snapshot ya calculado y actualiza el estado.
 *
 * Antes:  Frontend â†’ Twelve Data REST (consume crÃ©ditos)
 * Ahora:  Frontend â†’ Backend local â†’ Twelve Data WebSocket (0 crÃ©ditos)
 *
 * ReconexiÃ³n automÃ¡tica: si el backend se reinicia,
 * el frontend reconecta solo despuÃ©s de 3 segundos.
 */

import { useEffect, useRef, useState } from 'react'
import type { MarketSnapshot } from '@/types/market'

// â”€â”€â”€ âš™ï¸ CONFIGURACIÃ“N â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const BACKEND_WS_URL  = 'ws://localhost:8080'
const RECONNECT_MS    = 3_000

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export type FinalMarketView = {
  m5:         MarketSnapshot
  m15:        MarketSnapshot
  finalState: 'GREEN' | 'YELLOW' | 'RED'
}

type BackendMessage =
  | { type: 'snapshot'; m5: MarketSnapshot; m15: MarketSnapshot; finalState: 'GREEN' | 'YELLOW' | 'RED' }
  | { type: 'status';   status: string; message: string }
  | { type: 'error';    message: string }

export type ConnectionStatus = 'connecting' | 'connected' | 'disconnected'

export function useMarketData(): {
  data:   FinalMarketView | null
  status: ConnectionStatus
} {
  const [data,   setData]   = useState<FinalMarketView | null>(null)
  const [status, setStatus] = useState<ConnectionStatus>('connecting')
  const wsRef               = useRef<WebSocket | null>(null)
  const stoppedRef          = useRef(false)

  useEffect(() => {
    stoppedRef.current = false

    function connect() {
      if (stoppedRef.current) return

      console.log('[useMarketData] Conectando al backend...')
      setStatus('connecting')

      const ws = new WebSocket(BACKEND_WS_URL)
      wsRef.current = ws

      ws.onopen = () => {
        console.log('[useMarketData] Backend conectado âœ“')
        setStatus('connected')
      }

      ws.onmessage = (event: MessageEvent) => {
        let msg: BackendMessage
        try {
          msg = JSON.parse(event.data as string)
        } catch {
          return
        }

        if (msg.type === 'snapshot') {
          setData({
            m5:         msg.m5,
            m15:        msg.m15,
            finalState: msg.finalState,
          })
        }

        if (msg.type === 'status') {
          console.log(`[useMarketData] Backend status: ${msg.message}`)
          if (msg.status === 'disconnected') setStatus('disconnected')
          if (msg.status === 'connected')    setStatus('connected')
        }
      }

      ws.onerror = () => {
        console.error('[useMarketData] Error de conexiÃ³n con backend')
        setStatus('disconnected')
      }

      ws.onclose = () => {
        console.log('[useMarketData] Backend desconectado â€” reintentando...')
        setStatus('disconnected')
        if (!stoppedRef.current) {
          setTimeout(connect, RECONNECT_MS)
        }
      }
    }

    connect()

    return () => {
      stoppedRef.current = true
      wsRef.current?.close()
    }
  }, [])

  return { data, status }
} /**
 * useHistoricalData.ts
 *
 * Antes: llamaba directamente a Twelve Data REST (consumÃ­a crÃ©ditos)
 * Ahora: pide el historial al backend via HTTP
 *
 * El backend ya tiene las 500 velas histÃ³ricas cargadas al arrancar.
 * El frontend solo las pide para el backtest y la comparaciÃ³n contextual.
 *
 * Endpoint: GET http://localhost:8080/history?timeframe=5min
 */

import { useEffect, useState } from 'react'
import type { Candle } from '../backtest/types'

const BACKEND_HTTP_URL = 'http://localhost:8080'

export function useHistoricalData(): Candle[] | null {
  const [candles, setCandles] = useState<Candle[] | null>(null)

  useEffect(() => {
    fetch(`${BACKEND_HTTP_URL}/history?timeframe=5min`)
      .then((res) => res.json())
      .then((data: Candle[]) => {
        if (Array.isArray(data) && data.length > 0) {
          setCandles(data)
          console.log(`[useHistoricalData] ${data.length} velas recibidas del backend`)
        }
      })
      .catch((err) => {
        console.error('[useHistoricalData] Error al pedir historial al backend:', err)
      })
  }, [])

  return candles
} /**
 * useBacktest.ts
 *
 * Conecta el hook de React con el motor real de backtesting (runBacktest).
 *
 * ANTES: usaba Math.random() â†’ nÃºmeros ficticios, inÃºtiles para trading.
 * AHORA: usa runBacktest() con las velas reales de useHistoricalData.
 *
 * Â¿QuÃ© hace runBacktest?
 *   Recorre cada vela histÃ³rica, calcula elasticidad y percentil en ese
 *   punto, y si el estado serÃ­a GREEN busca cuÃ¡ntas velas tardÃ³ el precio
 *   en volver a la EMA. Eso genera eventos reales con win/loss verdaderos.
 *
 * useMemo â†’ solo recalcula cuando cambian las velas (no en cada render).
 * Con 300 velas M5 tarda < 5ms. No bloquea el hilo principal.
 */

import { useMemo } from 'react'
import type { BacktestResult } from '../backtest/types'
import type { Candle } from '../backtest/types'
import { runBacktest } from '../backtest/backtestEngine'

// ConfiguraciÃ³n del backtest â€” ajustar segÃºn calibraciÃ³n real
const BACKTEST_CONFIG = {
  emaPeriod:      100,   // velas para calcular EMA (igual que el motor en tiempo real)
  maxBarsToRevert: 20,   // mÃ¡ximo de velas que esperamos para reversiÃ³n
}

export function useBacktest(candles: Candle[] | null): BacktestResult | null {
  return useMemo(() => {
    // Necesitamos al menos emaPeriod + algo de historial para que sea Ãºtil
    if (!candles || candles.length < BACKTEST_CONFIG.emaPeriod + 10) {
      return null
    }

    return runBacktest(candles, BACKTEST_CONFIG)
  }, [candles])
}import type { MarketState } from '@/types/market'

/**
 * Traduce estadÃ­stica â†’ decisiÃ³n operativa
 */
export function resolveElasticityState(
  elasticity: number,
  percentile: number
): MarketState {

  // ğŸŸ¢ Zona Ã³ptima para reversiÃ³n
  if (percentile >= 75 && elasticity <= 5.5) {
    return 'GREEN'
  }

  // ğŸŸ¡ Estirado pero aÃºn posible
  if (percentile >= 55) {
    return 'YELLOW'
  }

  // ğŸ”´ Ruido / ruptura / no tocar
  return 'RED'
}
import type { MarketState } from '@/types/market'

/**
 * Traduce estadÃ­stica â†’ decisiÃ³n operativa
 */
export function resolveElasticityState(
  elasticity: number,
  percentile: number
): MarketState {

  // ğŸŸ¢ Zona Ã³ptima para reversiÃ³n
  if (percentile >= 75 && elasticity <= 5.5) {
    return 'GREEN'
  }

  // ğŸŸ¡ Estirado pero aÃºn posible
  if (percentile >= 55) {
    return 'YELLOW'
  }

  // ğŸ”´ Ruido / ruptura / no tocar
  return 'RED'
}
export type PercentileEngine = {
  push: (value: number) => number
  getHistory: () => number[]
  reset: () => void
}

export function createPercentileEngine(
  windowSize: number = 300
): PercentileEngine {
  let buffer: number[] = []

  function push(value: number): number {
    buffer.push(value)

    if (buffer.length > windowSize) {
      buffer.shift()
    }

    if (buffer.length === 1) return 0

    const sorted = [...buffer].sort((a, b) => a - b)
    const index = sorted.findIndex(v => v >= value)

    if (index === -1) return 100

    return Math.round((index / (sorted.length - 1)) * 100)
  }

  function getHistory() {
    return [...buffer]
  }

  function reset() {
    buffer = []
  }

  return {
    push,
    getHistory,
    reset,
  }
}
export function calculatePercentile(
  history: number[],
  current: number
): number {
  if (history.length === 0) return 0

  const sorted = [...history].sort((a, b) => a - b)
  const index = sorted.findIndex(v => v >= current)

  if (index === -1) return 100

  return Math.round((index / sorted.length) * 100)
}
 import type { MarketSnapshot } from '@/types/market'

export type MultiTFState = 'GREEN' | 'YELLOW' | 'RED'

export function resolveMultiTimeframeState(
  fast: MarketSnapshot,   // M5
  slow: MarketSnapshot    // M15
): MultiTFState {

  // ğŸŸ¢ Solo si AMBOS estÃ¡n verdes
  if (fast.state === 'GREEN' && slow.state === 'GREEN') {
    return 'GREEN'
  }

  // ğŸŸ¡ Timing ok pero contexto dudoso
  if (fast.state === 'GREEN' && slow.state === 'YELLOW') {
    return 'YELLOW'
  }

  // ğŸ”´ Todo lo demÃ¡s
  return 'RED'
}
import type { MarketSnapshot, MarketType } from '@/types/market'
import { calculateElasticity } from './elasticityEngine'
import { resolveElasticityState } from './stateEngine'
import { getPercentileEngine } from './engineRegistry'

export type MarketAssemblerInput = {
  marketType: MarketType
  pair: string
  timeframe: string
  price: number
  ema100: number
  atr: number
}

export function assembleMarketSnapshot(
  input: MarketAssemblerInput
): MarketSnapshot {

  const { marketType, pair, timeframe, price, ema100, atr } = input

  const elasticity = calculateElasticity({ price, ema100, atr })

  const engineKey = `${marketType}:${pair}:${timeframe}`
  const percentileEngine = getPercentileEngine(engineKey)

  const percentile = percentileEngine.push(elasticity)
  const state = resolveElasticityState(elasticity, percentile)

  return {
    marketType,
    pair,
    timeframe,
    price,
    ema100,
    atr,
    elasticity,
    percentile,
    state,
    timestamp: Date.now(),
  }
}
import { createPercentileEngine } from './percentileEngine'

type EngineKey = string

const registry = new Map<EngineKey, ReturnType<typeof createPercentileEngine>>()

export function getPercentileEngine(key: EngineKey) {
  if (!registry.has(key)) {
    registry.set(key, createPercentileEngine(300))
  }

  return registry.get(key)!
}
// ğŸ§  Engine puro (sin React)

export type ElasticityInput = {
  price: number
  ema100: number
  atr: number
}

/**
 * Elasticity = distancia a la EMA normalizada por ATR
 * Es adimensional â†’ comparable entre pares y timeframes
 */
export function calculateElasticity(
  { price, ema100, atr }: ElasticityInput
): number {
  if (atr <= 0) return 0
  return Math.abs(price - ema100) / atr
}
// ğŸ§  Engine puro (sin React)

export type ElasticityInput = {
  price: number
  ema100: number
  atr: number
}

/**
 * Elasticity = distancia a la EMA normalizada por ATR
 * Es adimensional â†’ comparable entre pares y timeframes
 */
export function calculateElasticity(
  { price, ema100, atr }: ElasticityInput
): number {
  if (atr <= 0) return 0
  return Math.abs(price - ema100) / atr
}
/**
 * Semaforo.tsx
 *
 * SeÃ±al de decisiÃ³n principal. Responde a: "Â¿QuÃ© hago ahora?"
 *
 * Incluye:
 *   - Guard contra state invÃ¡lido (evita crash si llega valor inesperado)
 *   - Contador de estabilidad: cuÃ¡ntas actualizaciones consecutivas
 *     lleva en el estado actual (clave para no operar en parpadeos)
 *   - Bloqueo por vela: solo marca "listo para operar" si lleva
 *     estable el tiempo equivalente a una vela M5 completa (~20 polls)
 */

import { useEffect, useRef, useState, type CSSProperties } from 'react'

export type SemaforoProps = {
  state:  'GREEN' | 'YELLOW' | 'RED'
  label?: string
}

type StateMeta = {
  color:    string
  bg:       string
  label:    string
  sublabel: string
}

const VALID_STATES = ['GREEN', 'YELLOW', 'RED'] as const
type ValidState = typeof VALID_STATES[number]

const STATE_META: Record<ValidState, StateMeta> = {
  GREEN: {
    color:    '#16a34a',
    bg:       'rgba(22,163,74,0.08)',
    label:    'SETUP VÃLIDO',
    sublabel: 'Condiciones Ã³ptimas para operar',
  },
  YELLOW: {
    color:    '#eab308',
    bg:       'rgba(234,179,8,0.08)',
    label:    'ESPERAR',
    sublabel: 'Condiciones parciales â€” sin seÃ±al clara',
  },
  RED: {
    color:    '#dc2626',
    bg:       'rgba(220,38,38,0.08)',
    label:    'NO OPERAR',
    sublabel: 'Condiciones desfavorables',
  },
}

// 20 polls Ã— 15s = 300s = 1 vela M5 completa
// Si el semÃ¡foro lleva 20 polls consecutivos en GREEN â†’ seÃ±al estable
const STABLE_THRESHOLD = 20   // polls para considerar seÃ±al confirmada
const POLL_SECONDS     = 15   // segundos entre cada poll (debe coincidir con useMarketData)

export function Semaforo({ state, label }: SemaforoProps) {
  // Guard: si state es invÃ¡lido, mostrar RED con aviso
  const safeState: ValidState = VALID_STATES.includes(state as ValidState)
    ? (state as ValidState)
    : 'RED'

  const meta = STATE_META[safeState]

  // â”€â”€ Contador de estabilidad â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const [count,    setCount]    = useState(0)
  const [elapsed,  setElapsed]  = useState(0)   // segundos en estado actual
  const prevStateRef            = useRef(safeState)
  const elapsedRef              = useRef<ReturnType<typeof setInterval> | null>(null)

  useEffect(() => {
    if (safeState === prevStateRef.current) {
      // Mismo estado â†’ incrementar contador
      setCount((c) => c + 1)
    } else {
      // CambiÃ³ â†’ reiniciar
      setCount(1)
      setElapsed(0)
      prevStateRef.current = safeState
    }
  }, [safeState])

  // Segundos transcurridos en el estado actual (para barra de progreso)
  useEffect(() => {
    setElapsed(0)
    if (elapsedRef.current) clearInterval(elapsedRef.current)
    elapsedRef.current = setInterval(() => {
      setElapsed((s) => s + 1)
    }, 1000)
    return () => {
      if (elapsedRef.current) clearInterval(elapsedRef.current)
    }
  }, [safeState])

  const isStable     = count >= STABLE_THRESHOLD && safeState === 'GREEN'
  const totalSeconds = STABLE_THRESHOLD * POLL_SECONDS
  const progressPct  = Math.min((elapsed / totalSeconds) * 100, 100)

  return (
    <div style={{
      ...styles.card,
      background: meta.bg,
      border: `1px solid ${meta.color}22`,
    }}>

      {label && <p style={styles.contextLabel}>{label}</p>}

      {/* CÃ­rculo con glow */}
      <div style={styles.circleWrapper}>
        <div style={{
          ...styles.circle,
          background:  meta.color,
          boxShadow:   `0 0 32px ${meta.color}88, 0 0 8px ${meta.color}`,
        }}/>
      </div>

      <h3 style={{ ...styles.mainLabel, color: meta.color }}>
        {meta.label}
      </h3>
      <p style={styles.sublabel}>{meta.sublabel}</p>

      {/* â”€â”€ SecciÃ³n de estabilidad â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */}
      <div style={styles.stabilitySection}>

        {/* Contador de polls consecutivos */}
        <div style={styles.stabilityRow}>
          <span style={styles.stabilityLabel}>Estabilidad</span>
          <span style={{ ...styles.stabilityValue, color: meta.color }}>
            {count} / {STABLE_THRESHOLD} polls consecutivos
          </span>
        </div>

        {/* Barra de progreso hacia seÃ±al estable */}
        <div style={styles.barTrack}>
          <div style={{
            ...styles.barFill,
            width:      `${progressPct}%`,
            background: meta.color,
            boxShadow:  `0 0 6px ${meta.color}66`,
          }}/>
        </div>

        {/* Tiempo en estado actual */}
        <div style={styles.stabilityRow}>
          <span style={styles.stabilityLabel}>Tiempo en este estado</span>
          <span style={{ ...styles.stabilityValue, color: '#555' }}>
            {Math.floor(elapsed / 60)}m {elapsed % 60}s
          </span>
        </div>

        {/* Badge de confirmaciÃ³n â€” aparece solo cuando es estable */}
        {isStable && (
          <div style={{
            ...styles.confirmedBadge,
            background: 'rgba(22,163,74,0.15)',
            border:     '1px solid #16a34a55',
          }}>
            <div style={{ width:6, height:6, borderRadius:'50%', background:'#16a34a', boxShadow:'0 0 6px #16a34a' }}/>
            <span style={{ color:'#16a34a', fontSize:11, fontWeight:800, letterSpacing:'0.05em' }}>
              SEÃ‘AL ESTABLE â€” 1 VELA M5 CONFIRMADA
            </span>
          </div>
        )}

        {/* GuÃ­a de lectura */}
        <p style={styles.guide}>
          {safeState === 'GREEN'
            ? isStable
              ? 'âœ“ El setup lleva estable el tiempo de una vela M5 completa.'
              : `Espera ${STABLE_THRESHOLD - count} polls mÃ¡s (${((STABLE_THRESHOLD - count) * POLL_SECONDS / 60).toFixed(1)} min) para confirmar estabilidad.`
            : 'El semÃ¡foro debe mantenerse verde antes de considerar operar.'}
        </p>

      </div>
    </div>
  )
}

// â”€â”€â”€ estilos â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const styles: Record<string, CSSProperties> = {
  card: {
    marginTop:    16,
    padding:      '20px 24px',
    borderRadius: 10,
    textAlign:    'center',
    fontFamily:   'system-ui, sans-serif',
    transition:   'background 0.4s, border 0.4s',
  },
  contextLabel: {
    margin:        '0 0 12px',
    fontSize:      11,
    color:         '#555',
    textTransform: 'uppercase' as const,
    letterSpacing: '0.08em',
  },
  circleWrapper: {
    display:        'flex',
    justifyContent: 'center',
    margin:         '0 auto 16px',
  },
  circle: {
    width:        72,
    height:       72,
    borderRadius: '50%',
    transition:   'background 0.4s, box-shadow 0.4s',
  },
  mainLabel: {
    margin:        '0 0 6px',
    fontSize:      18,
    fontWeight:    800,
    letterSpacing: '0.04em',
    transition:    'color 0.4s',
  },
  sublabel: {
    margin:   '0 0 16px',
    fontSize: 12,
    color:    '#555',
  },
  stabilitySection: {
    marginTop:    12,
    padding:      '12px 14px',
    background:   '#0d0d0d',
    borderRadius: 8,
    border:       '1px solid #1a1a1a',
    textAlign:    'left',
  },
  stabilityRow: {
    display:        'flex',
    justifyContent: 'space-between',
    alignItems:     'center',
    marginBottom:   6,
  },
  stabilityLabel: {
    fontSize: 11,
    color:    '#444',
    fontFamily: 'monospace',
  },
  stabilityValue: {
    fontSize:   11,
    fontWeight: 700,
    fontFamily: 'monospace',
  },
  barTrack: {
    height:       5,
    background:   '#1a1a1a',
    borderRadius: 3,
    overflow:     'hidden',
    marginBottom: 8,
  },
  barFill: {
    height:     '100%',
    borderRadius: 3,
    transition: 'width 1s linear',
  },
  confirmedBadge: {
    display:       'flex',
    alignItems:    'center',
    gap:           7,
    padding:       '8px 12px',
    borderRadius:  6,
    margin:        '10px 0 6px',
    justifyContent: 'center',
  },
  guide: {
    margin:   '8px 0 0',
    fontSize: 11,
    color:    '#444',
    fontFamily: 'monospace',
    lineHeight: 1.5,
  },
}/**
 * ElasticityCard.tsx
 *
 * Muestra el estado de elasticidad de M5 y M15 de forma visual.
 * Responde a: "Â¿EstÃ¡ el precio suficientemente estirado para operar?"
 *
 * Complementa al SemÃ¡foro:
 *   - SemÃ¡foro  â†’ "Â¿Opero o no?"       (decisiÃ³n)
 *   - Este card â†’ "Â¿Por quÃ© dice eso?" (contexto numÃ©rico + visual)
 */

import type { CSSProperties } from 'react'
import type { MarketSnapshot } from '@/types/market'
import type { MultiTFState } from '@/engine/multiTimeframeResolver'

// â”€â”€â”€ tipos â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export type ElasticityCardProps = {
  m5: MarketSnapshot
  m15: MarketSnapshot
  fusedState: MultiTFState
}

type StateMeta = {
  label: string
  color: string
  bg: string
  bar: string
}

type ZoneItem = {
  label: string
  range: string
  color: string
}

type TimeframeRowProps = {
  label: string
  snapshot: MarketSnapshot
}

// â”€â”€â”€ constantes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const STATE_META: Record<'GREEN' | 'YELLOW' | 'RED', StateMeta> = {
  GREEN:  { label: 'OPERAR',    color: '#16a34a', bg: 'rgba(22,163,74,0.12)',  bar: '#16a34a' },
  YELLOW: { label: 'ESPERAR',   color: '#eab308', bg: 'rgba(234,179,8,0.12)',  bar: '#eab308' },
  RED:    { label: 'NO OPERAR', color: '#dc2626', bg: 'rgba(220,38,38,0.12)', bar: '#dc2626' },
}

const ZONES: ZoneItem[] = [
  { label: 'Equilibrio', range: '< 0.5',   color: '#444' },
  { label: 'Bajo',       range: '0.5â€“1.0', color: '#666' },
  { label: 'Moderado',   range: '1.0â€“1.5', color: '#eab308' },
  { label: 'Alto',       range: '1.5â€“2.0', color: '#f97316' },
  { label: 'Extremo',    range: '> 2.0',   color: '#16a34a' },
]

// â”€â”€â”€ helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Convierte elasticidad a % para la barra visual.
 * Techo en 3.0 â†’ 100% (zona visualmente "llena" = extremo mÃ¡ximo).
 */
function elasticityToPercent(elasticity: number): number {
  return Math.min((elasticity / 3) * 100, 100)
}

/**
 * Etiqueta de zona para que el trader entienda el nÃºmero
 * sin necesidad de memorizar umbrales.
 */
function elasticityZoneLabel(elasticity: number): string {
  if (elasticity >= 2.0) return 'Extremo'
  if (elasticity >= 1.5) return 'Alto'
  if (elasticity >= 1.0) return 'Moderado'
  if (elasticity >= 0.5) return 'Bajo'
  return 'Equilibrio'
}

// â”€â”€â”€ subcomponente: fila de temporalidad â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function TimeframeRow({ label, snapshot }: TimeframeRowProps) {
  const meta = STATE_META[snapshot.state]
  const pct  = elasticityToPercent(snapshot.elasticity)
  const zone = elasticityZoneLabel(snapshot.elasticity)

  return (
    <div style={styles.row}>
      <span style={styles.rowLabel}>{label}</span>

      {/* Barra visual â€” cuÃ¡nto se estirÃ³ respecto al mÃ¡ximo esperado */}
      <div style={styles.barTrack}>
        <div
          style={{
            ...styles.barFill,
            width: `${pct}%`,
            background: meta.bar,
            boxShadow: `0 0 6px ${meta.bar}66`,
          }}
        />
      </div>

      {/* NÃºmero + etiqueta de zona */}
      <div style={styles.rowMeta}>
        <span style={{ color: meta.color, fontWeight: 700, fontFamily: 'monospace', fontSize: 15 }}>
          {snapshot.elasticity.toFixed(2)}
        </span>
        <span style={{ color: '#555', fontSize: 11, marginLeft: 6 }}>
          {zone}
        </span>
      </div>

      {/* Chip de estado */}
      <span
        style={{
          ...styles.chip,
          color: meta.color,
          background: meta.bg,
          border: `1px solid ${meta.color}44`,
        }}
      >
        {snapshot.state}
      </span>
    </div>
  )
}

// â”€â”€â”€ componente principal â€” export nombrado â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export function ElasticityCard({ m5, m15, fusedState }: ElasticityCardProps) {
  const fused = STATE_META[fusedState]

  return (
    <div style={styles.card}>

      {/* Header: par + badge de seÃ±al */}
      <div style={styles.header}>
        <div>
          <p style={styles.pair}>EUR / USD</p>
          <p style={styles.subtitle}>Elasticity System Â· M5 + M15</p>
        </div>

        <div
          style={{
            ...styles.summaryBadge,
            background: fused.bg,
            border: `1.5px solid ${fused.color}55`,
          }}
        >
          <div
            style={{
              width: 8,
              height: 8,
              borderRadius: '50%',
              background: fused.color,
              boxShadow: `0 0 8px ${fused.color}`,
              flexShrink: 0,
            }}
          />
          <span style={{ color: fused.color, fontWeight: 800, fontSize: 13, letterSpacing: '0.05em' }}>
            {fused.label}
          </span>
        </div>
      </div>

      <div style={styles.divider} />

      {/* Encabezado de columnas */}
      <div style={styles.tableHeader}>
        <span style={{ ...styles.colLabel, minWidth: 90 }}>Temporalidad</span>
        <span style={{ ...styles.colLabel, flex: 1, paddingLeft: 4 }}>Elasticidad</span>
        <span style={{ ...styles.colLabel, minWidth: 186, textAlign: 'right' }}>Estado</span>
      </div>

      <TimeframeRow label="M5  (seÃ±al)" snapshot={m5} />
      <TimeframeRow label="M15 (filtro)" snapshot={m15} />

      <div style={{ ...styles.divider, marginTop: 14 }} />

      {/* Leyenda de zonas */}
      <div>
        <span style={styles.legendTitle}>Zonas de elasticidad</span>
        <div style={styles.legendItems}>
          {ZONES.map((z: ZoneItem) => (
            <div key={z.label} style={styles.legendItem}>
              <span style={{ color: z.color, fontSize: 10, fontWeight: 700 }}>{z.label}</span>
              <span style={{ color: '#333', fontSize: 9, fontFamily: 'monospace' }}>{z.range}</span>
            </div>
          ))}
        </div>
      </div>

    </div>
  )
}

// â”€â”€â”€ estilos â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const styles: Record<string, CSSProperties> = {
  card: {
    background: '#0d0d0d',
    border: '1px solid #1e1e1e',
    borderRadius: 10,
    padding: '18px 20px',
    fontFamily: 'system-ui, sans-serif',
    color: '#ccc',
  },
  header: {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginBottom: 14,
  },
  pair: {
    margin: 0,
    fontSize: 18,
    fontWeight: 800,
    color: '#e5e5e5',
    letterSpacing: '-0.02em',
  },
  subtitle: {
    margin: '3px 0 0',
    fontSize: 11,
    color: '#444',
  },
  summaryBadge: {
    display: 'flex',
    alignItems: 'center',
    gap: 7,
    padding: '7px 14px',
    borderRadius: 20,
  },
  divider: {
    height: 1,
    background: '#1a1a1a',
    marginBottom: 12,
  },
  tableHeader: {
    display: 'flex',
    alignItems: 'center',
    gap: 8,
    marginBottom: 4,
  },
  colLabel: {
    fontSize: 9,
    color: '#3a3a3a',
    textTransform: 'uppercase' as const,
    letterSpacing: '0.08em',
  },
  row: {
    display: 'flex',
    alignItems: 'center',
    gap: 8,
    padding: '10px 0',
    borderBottom: '1px solid #161616',
  },
  rowLabel: {
    fontSize: 12,
    color: '#777',
    minWidth: 90,
    fontFamily: 'monospace',
  },
  barTrack: {
    flex: 1,
    height: 6,
    background: '#1a1a1a',
    borderRadius: 3,
    overflow: 'hidden',
  },
  barFill: {
    height: '100%',
    borderRadius: 3,
    transition: 'width 0.5s ease',
  },
  rowMeta: {
    display: 'flex',
    alignItems: 'baseline',
    minWidth: 110,
    justifyContent: 'flex-end',
  },
  chip: {
    fontSize: 10,
    fontWeight: 700,
    padding: '3px 8px',
    borderRadius: 4,
    letterSpacing: '0.05em',
    minWidth: 76,
    textAlign: 'center' as const,
  },
  legendTitle: {
    fontSize: 9,
    color: '#333',
    textTransform: 'uppercase' as const,
    letterSpacing: '0.08em',
  },
  legendItems: {
    display: 'flex',
    gap: 14,
    marginTop: 7,
    flexWrap: 'wrap' as const,
  },
  legendItem: {
    display: 'flex',
    flexDirection: 'column' as const,
    alignItems: 'center',
    gap: 2,
  },
}/**
 * DataStatus.tsx
 *
 * Panel de verificaciÃ³n de conexiÃ³n con datos reales.
 * Muestra de dÃ³nde viene cada dato para confirmar que no es simulaciÃ³n.
 *
 * Ãšsalo temporalmente en App.tsx para verificar la conexiÃ³n.
 * Una vez confirmado, puedes quitarlo del dashboard.
 */

import type { FinalMarketView } from '../hooks/useMarketData'
import type { Candle } from '../backtest/types'
import type { BacktestResult } from '../backtest/types'

type DataStatusProps = {
  market: FinalMarketView | null
  historical: Candle[] | null
  backtest: BacktestResult | null
}

type StatusRowProps = {
  label: string
  ok: boolean
  detail: string
}

function StatusRow({ label, ok, detail }: StatusRowProps) {
  return (
    <div style={{
      display: 'flex',
      alignItems: 'center',
      gap: 10,
      padding: '8px 0',
      borderBottom: '1px solid #1a1a1a',
    }}>
      {/* Indicador */}
      <div style={{
        width: 8,
        height: 8,
        borderRadius: '50%',
        flexShrink: 0,
        background: ok ? '#16a34a' : '#dc2626',
        boxShadow: ok ? '0 0 6px #16a34a' : '0 0 6px #dc2626',
      }} />

      {/* Label */}
      <span style={{ fontSize: 12, color: '#888', minWidth: 160, fontFamily: 'monospace' }}>
        {label}
      </span>

      {/* Detalle */}
      <span style={{ fontSize: 12, color: ok ? '#16a34a' : '#dc2626' }}>
        {detail}
      </span>
    </div>
  )
}

export function DataStatus({ market, historical, backtest }: DataStatusProps) {

  // â”€â”€ Verificaciones â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  // 1. WebSocket â€” precio real llega si market existe y cambia
  const wsOk      = market !== null
  const wsPrice   = market ? market.m5.price.toFixed(5) : 'â€”'
  const wsTs      = market ? new Date(market.m5.timestamp).toLocaleTimeString() : 'â€”'

  // 2. Velas histÃ³ricas â€” si son reales, el primer datetime no es "ahora"
  const histOk    = historical !== null && historical.length >= 100
  const histCount = historical ? historical.length : 0
  const histFirst = historical && historical.length > 0
    ? new Date(historical[0].time).toLocaleTimeString()
    : 'â€”'
  const histLast  = historical && historical.length > 0
    ? new Date(historical[historical.length - 1].time).toLocaleTimeString()
    : 'â€”'

  // 3. Backtest real â€” si estÃ¡ conectado al motor real, totalSignals no es
  //    igual a wins (Math.random hacÃ­a wins === totalSignals siempre)
  const btOk      = backtest !== null && backtest.totalSignals !== backtest.wins
  const btSignals = backtest ? backtest.totalSignals : 0
  const btWins    = backtest ? backtest.wins : 0
  const btWR      = backtest ? backtest.winRate : 0

  // 4. EMA real â€” si es real, ema100 es diferente al precio (no iguales)
  const emaOk     = market
    ? Math.abs(market.m5.price - market.m5.ema100) > 0.00001
    : false
  const emaVal    = market ? market.m5.ema100.toFixed(5) : 'â€”'

  // 5. ATR real â€” si es real, no es el fallback 0.0006 exacto
  const atrOk     = market ? market.m5.atr !== 0.0006 : false
  const atrVal    = market ? market.m5.atr.toFixed(6) : 'â€”'

  const allOk = wsOk && histOk && btOk && emaOk && atrOk

  return (
    <div style={{
      background: '#0d0d0d',
      border: `1px solid ${allOk ? '#16a34a44' : '#dc262644'}`,
      borderRadius: 8,
      padding: '14px 16px',
      fontFamily: 'system-ui, sans-serif',
    }}>
      {/* Header */}
      <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: 12 }}>
        <span style={{ fontSize: 12, color: '#555', textTransform: 'uppercase', letterSpacing: '0.08em' }}>
          Estado de conexiÃ³n
        </span>
        <span style={{
          fontSize: 11,
          fontWeight: 700,
          padding: '3px 10px',
          borderRadius: 12,
          color: allOk ? '#16a34a' : '#dc2626',
          background: allOk ? 'rgba(22,163,74,0.1)' : 'rgba(220,38,38,0.1)',
        }}>
          {allOk ? 'âœ“ DATOS REALES' : 'âš  VERIFICAR'}
        </span>
      </div>

      {/* Filas de verificaciÃ³n */}
      <StatusRow
        label="WebSocket (precio vivo)"
        ok={wsOk}
        detail={wsOk ? `${wsPrice} Â· ${wsTs}` : 'Sin conexiÃ³n'}
      />
      <StatusRow
        label="EMA100 (velas cerradas)"
        ok={emaOk}
        detail={emaOk ? `${emaVal}` : 'Usando fallback o mock'}
      />
      <StatusRow
        label="ATR14 (velas cerradas)"
        ok={atrOk}
        detail={atrOk ? `${atrVal}` : 'Usando fallback 0.0006'}
      />
      <StatusRow
        label="Historial REST"
        ok={histOk}
        detail={histOk
          ? `${histCount} velas Â· desde ${histFirst} hasta ${histLast}`
          : `Solo ${histCount} velas (necesita â‰¥ 100)`}
      />
      <StatusRow
        label="Backtest (motor real)"
        ok={btOk}
        detail={btOk
          ? `${btSignals} seÃ±ales Â· ${btWins} wins Â· WR ${btWR}%`
          : backtest
            ? `WR 100% con ${btSignals} seÃ±ales = datos ficticios`
            : 'Sin datos de backtest'}
      />

      {/* Nota */}
      <p style={{ margin: '10px 0 0', fontSize: 10, color: '#333', fontFamily: 'monospace' }}>
        * EMA/ATR se actualizan cada 5 min (M5) y cada 15 min (M15) con velas cerradas reales.
      </p>
    </div>
  )
} import type { BacktestResult } from '@/backtest/types'

export function BacktestMetrics({ data }: { data: BacktestResult }) {
  return (
    <div style={{ marginTop: 24, padding: 16, border: '1px solid #333' }}>
      <h3>ğŸ“Š Backtesting (Ãºltimas horas)</h3>
      <p>SeÃ±ales: {data.totalSignals}</p>
      <p>Win rate: {data.winRate}%</p>
      <p>Velas promedio a reversiÃ³n: {data.avgBarsToRevert}</p>
    </div>
  )
}
/**
 * backtestEngine.ts
 *
 * Motor de backtesting histÃ³rico. Analiza velas pasadas para:
 *   1. Detectar cuÃ¡ndo el sistema habrÃ­a generado una seÃ±al GREEN
 *   2. Medir si el precio revirtiÃ³ a la EMA dentro del lÃ­mite de velas
 *   3. Guardar estado y elasticidad de cada evento â†’ necesario para
 *      compareSignalWithHistory (comparaciÃ³n contextual)
 *
 * Cada BacktestEvent guarda:
 *   - entryIndex  â†’ Ã­ndice de la vela donde se detectÃ³ la seÃ±al
 *   - exitIndex   â†’ Ã­ndice donde revirtiÃ³ (-1 si no revirtiÃ³)
 *   - barsToRevert â†’ cuÃ¡ntas velas tardÃ³ en revertir
 *   - state       â†’ GREEN/YELLOW/RED en ese momento (siempre GREEN aquÃ­)
 *   - elasticity  â†’ valor exacto de elasticidad en ese momento
 *                   â†‘ este campo es el que permite la comparaciÃ³n contextual
 */

import type {
  Candle,
  BacktestConfig,
  BacktestEvent,
  BacktestResult,
} from './types'

import { calculateElasticity } from '@/engine/elasticityEngine'
import { resolveElasticityState } from '@/engine/stateEngine'
import { createPercentileEngine } from '@/engine/percentileEngine'

export function runBacktest(
  candles: Candle[],
  config: BacktestConfig
): BacktestResult {
  const percentileEngine = createPercentileEngine(200)

  const events: BacktestEvent[] = []

  for (let i = config.emaPeriod; i < candles.length; i++) {
    const candle = candles[i]

    // 1ï¸âƒ£ EMA simple sobre las Ãºltimas `emaPeriod` velas
    //    Para backtest es suficiente â€” no necesitamos EMA exponencial exacta
    const slice = candles.slice(i - config.emaPeriod, i)
    const ema   = slice.reduce((sum, c) => sum + c.close, 0) / config.emaPeriod

    // 2ï¸âƒ£ ATR de la vela actual (High - Low)
    //    Fallback 0.0001 para evitar divisiÃ³n por cero en velas planas
    const atr = Math.abs(candle.high - candle.low) || 0.0001

    // 3ï¸âƒ£ Elasticidad = distancia a EMA normalizada por ATR
    const elasticity = calculateElasticity({
      price:  candle.close,
      ema100: ema,
      atr,
    })

    // 4ï¸âƒ£ Percentil dentro de la ventana de 200 velas
    const percentile = percentileEngine.push(elasticity)

    // 5ï¸âƒ£ Estado semÃ¡foro en este punto histÃ³rico
    const state = resolveElasticityState(elasticity, percentile)

    // Solo registramos eventos cuando habrÃ­a habido seÃ±al GREEN
    if (state !== 'GREEN') continue

    // 6ï¸âƒ£ Buscar reversiÃ³n en las siguientes `maxBarsToRevert` velas
    //    ReversiÃ³n = precio toca la EMA desde el lado contrario
    let reverted = false

    for (
      let j = 1;
      j <= config.maxBarsToRevert && i + j < candles.length;
      j++
    ) {
      const future = candles[i + j]

      const revertedDown = candle.close > ema && future.low  <= ema
      const revertedUp   = candle.close < ema && future.high >= ema

      if (revertedDown || revertedUp) {
        events.push({
          entryIndex:   i,
          exitIndex:    i + j,
          barsToRevert: j,
          state,        // â† siempre GREEN (solo entramos si state === 'GREEN')
          elasticity,   // â† valor exacto para compareSignalWithHistory
        })
        reverted = true
        break
      }
    }

    // Si no revirtiÃ³ dentro del lÃ­mite â†’ loss (exitIndex = -1)
    if (!reverted) {
      events.push({
        entryIndex:   i,
        exitIndex:    -1,
        barsToRevert: config.maxBarsToRevert,
        state,
        elasticity,
      })
    }
  }

  // ğŸ“Š MÃ©tricas finales
  const wins         = events.filter(e => e.exitIndex !== -1)
  const totalSignals = events.length

  return {
    totalSignals,
    wins:    wins.length,
    winRate:
      totalSignals === 0
        ? 0
        : Math.round((wins.length / totalSignals) * 100),
    avgBarsToRevert:
      wins.length === 0
        ? 0
        : Math.round(
            wins.reduce((s, e) => s + e.barsToRevert, 0) / wins.length
          ),
    events,  // â† necesario para compareSignalWithHistory
  }
} import type { BacktestResult } from './types'
import type { MarketState } from '../types/market'

export type SignalComparisonResult = {
  similarSignals: number
  winRate: number
  avgBarsToRevert: number
}

export function compareSignalWithHistory(
  current: {
    state: MarketState
    elasticity: number
  },
  backtest: BacktestResult
): SignalComparisonResult {
  const similar = backtest.events.filter(
    e =>
      e.state === current.state &&
      Math.abs(e.elasticity - current.elasticity) < 0.1
  )

  const wins = similar.length

  return {
    similarSignals: similar.length,
    winRate:
      similar.length > 0 ? (wins / similar.length) * 100 : 0,
    avgBarsToRevert:
      similar.reduce((a, e) => a + e.barsToRevert, 0) /
      (similar.length || 1),
  }
} export type MarketBias = 'bullish' | 'bearish' | 'neutral'

export function mapStateToBias(
  state: 'GREEN' | 'YELLOW' | 'RED'
): MarketBias {
  if (state === 'GREEN') return 'bullish'
  if (state === 'RED') return 'bearish'
  return 'neutral'
}
export type MarketBias = 'bullish' | 'bearish' | 'neutral'

export function mapStateToBias(
  state: 'GREEN' | 'YELLOW' | 'RED'
): MarketBias {
  if (state === 'GREEN') return 'bullish'
  if (state === 'RED') return 'bearish'
  return 'neutral'
}
/**
 * backtest/types.ts
 *
 * Tipos del mÃ³dulo de backtesting.
 * Todos los archivos de backtest importan desde aquÃ­.
 */

// Una vela OHLC estÃ¡ndar
export type Candle = {
  time:  number
  open:  number
  high:  number
  low:   number
  close: number
}

export type HistoricalMarketData = {
  candles: Candle[]
}

/**
 * ConfiguraciÃ³n que recibe runBacktest.
 * emaPeriod      â†’ velas para calcular la EMA de referencia
 * maxBarsToRevert â†’ mÃ¡ximo de velas que esperamos para que el precio revierta
 */
export type BacktestConfig = {
  emaPeriod:       number
  maxBarsToRevert: number
}

/**
 * Un evento registrado durante el backtest.
 * Guarda estado y elasticidad para que compareSignalWithHistory
 * pueda buscar situaciones similares a la seÃ±al actual.
 */
export type BacktestEvent = {
  entryIndex:   number
  exitIndex:    number   // -1 si no revirtiÃ³ (loss)
  barsToRevert: number
  state:        'GREEN' | 'YELLOW' | 'RED'
  elasticity:   number
}

/**
 * Resultado completo del backtest.
 * events es necesario para compareSignalWithHistory.
 */
export type BacktestResult = {
  totalSignals:    number
  wins:            number
  winRate:         number
  avgBarsToRevert: number
  events:          BacktestEvent[]
}

export type CurrentSignal = {
  elasticity: number
  state:      'bullish' | 'bearish' | 'neutral'
}

export type SignalMatchResult = {
  similarSignals:  number
  winRate:         number
  avgBarsToRevert: number
}/**
 * backtest/types.ts
 *
 * Tipos del mÃ³dulo de backtesting.
 * Todos los archivos de backtest importan desde aquÃ­.
 */

// Una vela OHLC estÃ¡ndar
export type Candle = {
  time:  number
  open:  number
  high:  number
  low:   number
  close: number
}

export type HistoricalMarketData = {
  candles: Candle[]
}

/**
 * ConfiguraciÃ³n que recibe runBacktest.
 * emaPeriod      â†’ velas para calcular la EMA de referencia
 * maxBarsToRevert â†’ mÃ¡ximo de velas que esperamos para que el precio revierta
 */
export type BacktestConfig = {
  emaPeriod:       number
  maxBarsToRevert: number
}

/**
 * Un evento registrado durante el backtest.
 * Guarda estado y elasticidad para que compareSignalWithHistory
 * pueda buscar situaciones similares a la seÃ±al actual.
 */
export type BacktestEvent = {
  entryIndex:   number
  exitIndex:    number   // -1 si no revirtiÃ³ (loss)
  barsToRevert: number
  state:        'GREEN' | 'YELLOW' | 'RED'
  elasticity:   number
}

/**
 * Resultado completo del backtest.
 * events es necesario para compareSignalWithHistory.
 */
export type BacktestResult = {
  totalSignals:    number
  wins:            number
  winRate:         number
  avgBarsToRevert: number
  events:          BacktestEvent[]
}

export type CurrentSignal = {
  elasticity: number
  state:      'bullish' | 'bearish' | 'neutral'
}

export type SignalMatchResult = {
  similarSignals:  number
  winRate:         number
  avgBarsToRevert: number
}





 tu consola:
1. Refused to display 'https://cdn.ritekit.com/' in a frame...
Â¿QuÃ© es? RiteKit es una herramienta de redes sociales/SEO. Esto no es tu cÃ³digo. Es una extensiÃ³n de tu navegador (probablemente RiteTag o similar) que estÃ¡ intentando inyectar un iframe en tu pÃ¡gina local y el navegador la bloquea por seguridad.
SoluciÃ³n: IgnÃ³ralo por completo, o deshabilita esa extensiÃ³n para localhost.
2. Failed to load resource: 404 ()
Â¿QuÃ© es? Suele ser el navegador buscando el archivo favicon.ico (el Ã­cono de la pestaÃ±a) y no lo encuentra en tu carpeta public.
SoluciÃ³n: Inofensivo. Si quieres que desaparezca, solo pon cualquier imagen llamada favicon.ico en la carpeta public de tu frontend.
3. WebSocket connection to 'ws://localhost:8081/' failed (en refresh.js)
Â¿QuÃ© es? Ese puerto 8081 y el archivo refresh.js le pertenecen a Vite (tu entorno de desarrollo de React). Es el sistema de "Hot Reload" que refresca la pÃ¡gina cuando guardas un archivo. A veces al recargar la pÃ¡gina a mano, Vite pierde la conexiÃ³n un segundo y tira ese error.
SoluciÃ³n: Inofensivo. DesaparecerÃ¡ solo cuando compiles el proyecto para producciÃ³n (npm run build).
4. EL ÃšNICO ERROR TUYO: WebSocket is closed before the connection is established
Esto es muy interesante. Notaste que en tu backend dice:
[Server] Frontend conectado 
â†’
â†’
 desconectado 
â†’
â†’
 conectado
Â¿Por quÃ© pasa? EstÃ¡s usando React 18 en modo estricto (<StrictMode>). En desarrollo, React renderiza los componentes dos veces seguidas intencionalmente (Monta 
â†’
â†’
 Desmonta 
â†’
â†’
 Monta) para asegurarse de que limpiaste bien tus efectos.
Â¿QuÃ© ocurre?
React monta useMarketData y abre el WebSocket.
Un milisegundo despuÃ©s, React lo desmonta (StrictMode). Tu cÃ³digo de limpieza hace ws.close().
Como el WebSocket apenas se estaba abriendo (no habÃ­a terminado de conectarse) y tÃº lo mandaste a cerrar, el navegador lanza esa advertencia roja: "Oye, lo cerraste antes de que se conectara".
React lo vuelve a montar y esta vez sÃ­ se queda conectado (por eso funciona perfecto).
SoluciÃ³n (Para dejar la consola limpiecita):
Abre tu archivo useMarketData.ts y baja hasta el final del useEffect (donde estÃ¡ el return () => { ... }). Reemplaza ese pequeÃ±o bloque por este:
code
TypeScript
return () => {
      stoppedRef.current = true
      const ws = wsRef.current
      if (ws) {
        // Limpiamos los eventos para que no disparen errores al desmontar
        ws.onerror = null
        ws.onclose = null
        
        // Si estaba a medio conectar, le decimos que se cierre apenas termine
        if (ws.readyState === WebSocket.CONNECTING) {
          ws.onopen = () => ws.close()
        } else {
          // Si ya estaba conectado o cerrado, lo cerramos normal
          ws.close()
        }
      }
    }
Resumen